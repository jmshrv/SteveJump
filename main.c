#include "SDL.h"#include <stdlib.h>#define WIDTH 1024#define HEIGHT 768#define MOVEMENT_SPEED 30#define GRAVITY 2#define STEVE_WIDTH 70#define STEVE_HEIGHT 88#define PLATFORM_WIDTH 216#define PLATFORM_HEIGHT 38#define BOUNCE_VELOCITY -50;SDL_Surface* init();SDL_Surface* init() {	SDL_Surface* screen;	Uint32 black;		if(SDL_Init(SDL_INIT_EVERYTHING) < 0) {    	ExitToShell();    	return NULL;  	}	screen = SDL_SetVideoMode(WIDTH, HEIGHT, 0, SDL_ANYFORMAT | SDL_DOUBLEBUF | SDL_FULLSCREEN);	if(!screen) {    	// didn't initialize - maybe out of memory? (see above)    	ExitToShell();    	return NULL;  	}    black = SDL_MapRGB(screen->format, 0, 0, 0);  SDL_WM_SetCaption("Hello SDL!", NULL);  SDL_FillRect(screen, NULL, black);    return screen;}void load_asset(char* path, int x, int y, SDL_Surface** steveJobs, SDL_Rect* steveJobsRect, SDL_Surface** screen) {	int colorKey;	SDL_Surface* loadTemp = SDL_LoadBMP(path);  	if (loadTemp == NULL) {		ExitToShell();  		return;  	}  	*steveJobs = SDL_DisplayFormat(loadTemp);	SDL_FreeSurface(loadTemp);  	colorKey = SDL_MapRGB((*screen)->format, 255, 0, 255);	SDL_SetColorKey(*steveJobs, SDL_SRCCOLORKEY | SDL_RLEACCEL, colorKey);	steveJobsRect->x = x;	steveJobsRect->y = y;};int is_colliding(int steveVelocity, SDL_Rect* steveJobsRect, SDL_Rect* platformRect) {//	int xDiff;//	int yDiff;//	int isXflush;//	int isYflush;//	//	if (steveVelocity > 0) {//		// Let steve "pass through" the platform//		return 0;//	}//	//	xDiff = steveJobsRect->x - platformRect->x;//	yDiff = steveJobsRect->y - platformRect->y;//	//	isXflush = xDiff > -STEVE_WIDTH && xDiff < PLATFORM_WIDTH;//	isYflush = yDiff > -STEVE_HEIGHT && yDiff < PLATFORM_HEIGHT;//	//	return isXflush || isYflush;		int leftA, leftB;	int rightA, rightB;	int topA, topB;	int bottomA, bottomB;		if (steveVelocity < 0) {		// Let steve "pass through" the platform		return 0;	}		leftA = steveJobsRect->x;	rightA = steveJobsRect->x + STEVE_WIDTH;	topA = steveJobsRect->y;	bottomA = steveJobsRect->y + STEVE_HEIGHT;		leftB = platformRect->x;	rightB = platformRect->x + PLATFORM_WIDTH;	topB = platformRect->y;	bottomB = platformRect->y + PLATFORM_HEIGHT;		if (bottomA <= topB || topA >= bottomB || rightA <= leftB || leftA >= rightB) {		return 0;	}		return 1;}void random_rect(SDL_Rect* rect) {	rect->x = (rand() % WIDTH);	rect->y = (rand() % HEIGHT) - HEIGHT / 2;}int SDL_main(int argc, char** argv) {  Uint8* keys;  SDL_Event event;    SDL_Surface* steveJobs;  SDL_Rect steveJobsRect;  int steveVelocity         = 0;    SDL_Surface* platform;  SDL_Rect platformRect;    SDL_Surface* screen = init();    load_asset("SteveJobs.bmp", WIDTH / 2, HEIGHT / 2, &steveJobs, &steveJobsRect, &screen);  load_asset("G3s/Indigo.bmp", WIDTH / 2, HEIGHT - 100, &platform, &platformRect, &screen);  while(true) {  	// Clear the background    SDL_FillRect(screen, NULL, 0);        while(SDL_PollEvent(&event)) {      // This event doesn't seem to work (see below)      // but you need to poll events, otherwise the app will lock up      // the machine.      if(event.type == SDL_QUIT) { break; }    }    keys = SDL_GetKeyState(NULL);    if(keys[SDLK_ESCAPE]) {      break;    }        if (keys[SDLK_LEFT]) {    	steveJobsRect.x -= MOVEMENT_SPEED;    }    if (keys[SDLK_RIGHT]) {    	steveJobsRect.x += MOVEMENT_SPEED;    }        if (is_colliding(steveVelocity, &steveJobsRect, &platformRect)) {    // if (steveJobsRect.y > (HEIGHT - 100)) {    	steveVelocity = BOUNCE_VELOCITY;    	random_rect(&platformRect);    } else {    	steveVelocity += GRAVITY;    }        platformRect.y -= steveVelocity;        SDL_BlitSurface(steveJobs, NULL, screen, &steveJobsRect);    SDL_BlitSurface(platform, NULL, screen, &platformRect);    	// SDL_Flip does this for us  	// SDL_UpdateRect(screen, 0, 0, 0, 0);        SDL_Flip(screen);    // SDL_Delay(1 / 75);  }  return 0;}